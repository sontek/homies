#!/usr/bin/env bash
# ralph - Autonomous Claude Code workflow orchestration
# Executes: implementation → test → review → commit → PR → iterate
set -euo pipefail

# Detect script directory to find claude-jail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Configuration (can be overridden by environment variables)
RALPH_MAX_ITERATIONS="${RALPH_MAX_ITERATIONS:-50}"
RALPH_COST_LIMIT="${RALPH_COST_LIMIT:-10.00}"
RALPH_AUTO_APPROVE_PUSH="${RALPH_AUTO_APPROVE_PUSH:-false}"
RALPH_DIR="${RALPH_DIR:-.ralph}"
RALPH_AUDIT_DIR="${RALPH_AUDIT_DIR:-.ralph/audit}"
RALPH_RUNS_DIR="${RALPH_RUNS_DIR:-.ralph/runs}"
RALPH_CLAUDE_COMMAND="${RALPH_CLAUDE_COMMAND:-claude-jail}"

# Determine Claude command path
if [ "$RALPH_CLAUDE_COMMAND" = "claude-jail" ]; then
    CLAUDE_CMD="${SCRIPT_DIR}/claude-jail"
elif [ "$RALPH_CLAUDE_COMMAND" = "claude" ]; then
    CLAUDE_CMD="claude"
else
    # Assume it's a custom path/command
    CLAUDE_CMD="$RALPH_CLAUDE_COMMAND"
fi

# Generate unique run ID (timestamp-based)
RALPH_RUN_ID="ralph-$(date +%Y%m%d-%H%M%S)"

# State file for current run
STATE_FILE="$RALPH_DIR/state.json"

# Run-specific directory for this execution
RUN_DIR="$RALPH_RUNS_DIR/$RALPH_RUN_ID"

# Plan file for current run
PLAN_FILE="$RUN_DIR/plan.md"

# Decisions file for current run (logs what was done each iteration)
DECISIONS_FILE="$RUN_DIR/decisions.md"

# Claude Code uses .claude/ for its own files (todos.json)
# Ralph uses .ralph/ for its own files (state, audit, runs)
CLAUDE_DIR=".claude"

# Circuit breaker tracking (for stagnation detection)
LAST_ERROR_MSG=""
ERROR_REPEAT_COUNT=0
TEST_ONLY_LOOP_COUNT=0
NO_PROGRESS_COUNT=0
LAST_COMPLETED_TASKS=0
LAST_FILES_MODIFIED=0

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

# Usage
usage() {
    cat <<EOF
Usage: ralph [OPTIONS] PROMPT

Run autonomous Claude Code workflow on a prompt.

PROMPT can be:
  - A string: ralph "implement feature X"
  - A file path: ralph tasks/task1.md
  - Stdin: echo "task" | ralph

Options:
  --resume     Resume from last checkpoint
  --help       Show this help

Environment variables:
  RALPH_MAX_ITERATIONS      Max total iterations (default: 20)
  RALPH_COST_LIMIT          Max cost in USD (default: 10.00)
  RALPH_AUTO_APPROVE_PUSH   Skip push approval (default: false)
  RALPH_CLAUDE_COMMAND      Claude command to use (default: claude-jail)
                            Options: "claude", "claude-jail", or custom path

Examples:
  ralph "Add user authentication"
  ralph docs/implementation.md
  RALPH_MAX_ITERATIONS=30 ralph "complex task"
  RALPH_CLAUDE_COMMAND=claude ralph "use native claude"
EOF
    exit 1
}

# Initialize directories
init_dirs() {
    mkdir -p "$RALPH_DIR"
    mkdir -p "$RALPH_AUDIT_DIR"
    mkdir -p "$RALPH_RUNS_DIR"
    mkdir -p "$RUN_DIR"  # Create run-specific directory
    mkdir -p "$CLAUDE_DIR"  # Ensure .claude exists for todos.json
}

# Archive old state files from previous run
archive_old_state() {
    # Check if there are any state files from previous run
    local has_old_files=false

    if [ -f "$STATE_FILE" ] || [ -f "$CLAUDE_DIR/todos.json" ]; then
        has_old_files=true
    fi

    if [ "$has_old_files" = true ]; then
        # Find the most recent run directory (if any exist)
        local latest_run=$(ls -t "$RALPH_RUNS_DIR" 2>/dev/null | head -1)

        if [ -n "$latest_run" ]; then
            local archive_dir="$RALPH_RUNS_DIR/$latest_run"
        else
            # First run, create archive with timestamp
            local archive_dir="$RALPH_RUNS_DIR/ralph-previous-$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$archive_dir"
        fi

        log_info "Archiving previous run state to: $archive_dir"

        # Move old state files to archive
        [ -f "$STATE_FILE" ] && mv "$STATE_FILE" "$archive_dir/" 2>/dev/null || true
        [ -f "$CLAUDE_DIR/todos.json" ] && mv "$CLAUDE_DIR/todos.json" "$archive_dir/" 2>/dev/null || true
    fi
}

# Get prompt from various sources
get_prompt() {
    local arg="$1"

    # Check if it's a file first
    if [ -n "$arg" ] && [ -f "$arg" ]; then
        cat "$arg"
    # Check if we have a direct string argument
    elif [ -n "$arg" ]; then
        echo "$arg"
    # Otherwise check if reading from stdin
    elif [ ! -t 0 ]; then
        cat
    else
        echo ""
    fi
}

# Initialize state
init_state() {
    local prompt="$1"
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "$STATE_FILE" <<EOF
{
  "total_iterations": 0,
  "cost_usd": 0.0,
  "started_at": "$timestamp",
  "updated_at": "$timestamp",
  "prompt": $(echo "$prompt" | jq -Rs .),
  "last_completed_count": 0,
  "no_progress_iterations": 0,
  "current_phase": 1,
  "phase_iterations": 0
}
EOF
}

# Load state
load_state() {
    if [ -f "$STATE_FILE" ]; then
        cat "$STATE_FILE"
    else
        echo "{}"
    fi
}

# Update state
update_state() {
    local updates="$1"
    local current_state=$(load_state)
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    echo "$current_state" | jq ". + $updates + {\"updated_at\": \"$timestamp\"}" > "$STATE_FILE"
}

# Approval gate
approval_gate() {
    local message="$1"

    if [ "$RALPH_AUTO_APPROVE_PUSH" = "true" ]; then
        log_info "Auto-approving: $message"
        return 0
    fi

    echo ""
    log_warning "$message"
    read -p "Continue? (y/n) " -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_error "Aborted by user"
        return 1
    fi

    return 0
}

# Check iteration limits
check_limits() {
    local state=$(load_state)
    local total_iterations=$(echo "$state" | jq -r '.total_iterations // 0')

    if [ "$total_iterations" -ge "$RALPH_MAX_ITERATIONS" ]; then
        log_error "Max iterations ($RALPH_MAX_ITERATIONS) reached"
        return 1
    fi

    # TODO: Add cost checking once we can track API costs
    # local cost=$(echo "$state" | jq -r '.cost_usd // 0')
    # if (( $(echo "$cost >= $RALPH_COST_LIMIT" | bc -l) )); then
    #     log_error "Cost limit ($RALPH_COST_LIMIT USD) reached"
    #     return 1
    # fi

    return 0
}

# Helper: Check if a phase has unchecked tasks
phase_has_unchecked() {
    local phase=$1
    [ ! -f "$PLAN_FILE" ] && return 1

    # Use awk to count unchecked tasks in the phase section
    # Start at phase header, process until next phase header (excluding current phase)
    # This handles whitespace variations: - [ ], -  [ ], etc.
    local count=$(awk -v phase="$phase" '
        /^## Phase [0-9]+:/ {
            # Found a phase header
            phase_num = $3
            gsub(/:/, "", phase_num)
            in_target_phase = (phase_num == phase)
            next
        }
        in_target_phase && /^-[ \t]+\[[ \t]\]/ {
            # Found unchecked task in target phase
            count++
        }
        END { print count+0 }
    ' "$PLAN_FILE")

    [ "$count" -gt 0 ] && return 0 || return 1
}

# Helper: Check if all tasks in a phase are complete
phase_tasks_complete() {
    local phase=$1
    [ ! -f "$PLAN_FILE" ] && return 1

    # Phase is complete if it has no unchecked tasks
    ! phase_has_unchecked "$phase"
}

# Detect if current phase is complete
detect_phase_completion() {
    local phase=$1

    case $phase in
        1)
            # Phase 1 complete when plan.md exists with proper structure AND all Phase 1 tasks are checked
            if [ -f "$PLAN_FILE" ] && grep -q "^## Phase 9:" "$PLAN_FILE"; then
                # Plan file exists with all phases, now check if Phase 1 tasks are done
                phase_tasks_complete 1 && return 0
            fi
            ;;
        2)
            # Phase 2 complete when all Phase 2 tasks are checked
            phase_tasks_complete 2 && return 0
            ;;
        3)
            # Phase 3 complete when all Phase 3 review tasks are checked
            # After completion, will advance to Phase 4 (if tasks added) or Phase 5
            phase_tasks_complete 3 && return 0
            ;;
        4)
            # Phase 4 complete when all fix tasks done (returns to Phase 3)
            phase_tasks_complete 4 && return 0
            ;;
        5)
            # Phase 5 complete when all Phase 5 test tasks are checked
            # After completion, will advance to Phase 6 (if tasks added) or Phase 7
            phase_tasks_complete 5 && return 0
            ;;
        6)
            # Phase 6 complete when all fix tasks done (returns to Phase 5)
            phase_tasks_complete 6 && return 0
            ;;
        7)
            # Phase 7 complete when all Phase 7 final review tasks are checked
            # After completion, will advance to Phase 8 (if tasks added) or Phase 9
            phase_tasks_complete 7 && return 0
            ;;
        8)
            # Phase 8 complete when all fix tasks done (returns to Phase 5 to re-test)
            phase_tasks_complete 8 && return 0
            ;;
        9)
            # Phase 9 complete when commit task is checked
            phase_tasks_complete 9 && return 0
            ;;
    esac
    return 1
}

# Determine next phase based on current phase
determine_next_phase() {
    local current=$1

    case $current in
        1) echo 2 ;;  # Plan → Implement
        2) echo 3 ;;  # Implement → Review
        3)
            # Review → Fix (if issues) or Test (if clean)
            phase_has_unchecked 4 && echo 4 || echo 5
            ;;
        4) echo 3 ;;  # Fix → Re-review
        5)
            # Test → Fix (if failures) or Final-Review (if passing)
            phase_has_unchecked 6 && echo 6 || echo 7
            ;;
        6) echo 5 ;;  # Fix → Re-test
        7)
            # Final-Review → Fix (if issues) or Commit (if clean)
            phase_has_unchecked 8 && echo 8 || echo 9
            ;;
        8) echo 5 ;;  # Fix → Re-test (ensures fixes didn't break anything, then re-review)
        9) echo "done" ;;  # Commit → Done
        *) echo "error" ;;
    esac
}

# Get generic system prompt (same for all phases)
get_system_prompt() {
    cat <<'EOF'
You are running in an autonomous workflow system called Ralph.

Ralph orchestrates a 9-phase development workflow:
1. PLAN - Create implementation plan
2. IMPLEMENT - Write code
3. REVIEW - Code review
4. FIX - Fix review issues (returns to Phase 3)
5. TEST - Run tests/linter/type checker
6. FIX - Fix test failures (returns to Phase 5)
7. FINAL-REVIEW - Final verification before commit
8. FIX - Final fixes (returns to Phase 5 to re-test and re-review)
9. COMMIT - Create git commit

Phase flow ensures quality:
- Phase 4 fixes → re-review (Phase 3)
- Phase 6 fixes → re-test (Phase 5)
- Phase 8 fixes → re-test (Phase 5) → re-review (Phase 7) → commit (Phase 9)

STATELESS OPERATION (CRITICAL):
You are called iteratively. Each invocation should complete ONE task from the plan, then STOP.
Do not continue to additional tasks. Ralph controls phase transitions and will call you again
for the next task. You have NO MEMORY of previous invocations - rebuild context by reading:
1. DECISIONS_FILE_PATH (what happened in previous iterations)
2. git status and git diff (current state)
3. The plan file (what's done, what's remaining)

Ralph may call you multiple times for the same phase if multiple tasks exist. Each call completes
ONE task. Ralph automatically detects when all tasks in a phase are complete and transitions to
the next phase. You do NOT control phase transitions.

STOP CONDITION:
After completing your assigned task and marking it [x] in the plan, your work for this iteration
is COMPLETE. Do not proceed to additional tasks, create new tasks, or continue working. Do not
explain what you'll do next or prepare for future work. STOP IMMEDIATELY after:
1. Completing the one task assigned to you
2. Marking that task as [x] in the plan file
3. Logging the outcome to DECISIONS_FILE_PATH

CRITICAL AUTONOMOUS WORKFLOW RULES:
- Work on ONE task at a time from the plan (even if multiple similar tasks exist)
- ACTUALLY EXECUTE commands (tests, linter, etc.) - don't just document how to run them
- Wait for commands to complete and verify results
- Be MINIMAL - only create files necessary for implementation
- Follow existing project conventions (check justfile, package.json, Makefile, etc.)
- DO NOT create user-facing documentation (README.md, SUMMARY.md, HOWTO.md) unless explicitly requested
- DO NOT create bash scripts if project uses other tools (justfile, npm scripts)
- DO NOT stage/commit:
  - .claude/ or .ralph/ directories
  - Documentation summaries, implementation guides, planning documents you create
  - Temporary helper scripts (unless they're part of the actual implementation)
- ONLY stage actual implementation files (source code, tests, config files)
- Log all decisions and test results to DECISIONS_FILE_PATH

EFFICIENT CODEBASE EXPLORATION:
When you need to understand the codebase or find files/code:
- Use the Task tool with Explore subagent (subagent_type="Explore") for open-ended searches
- Examples: "Where is authentication handled?", "Find all API endpoints", "How does error handling work?"
- Do NOT use Glob/Grep directly for exploratory questions - subagents are more efficient
- Only use Glob/Grep for specific, targeted searches when you know what you're looking for

SCOPE BOUNDARIES (resist the urge to be "helpful"):
- Do NOT fix unrelated bugs you notice
- Do NOT refactor code not mentioned in your specific task
- Do NOT add features not in the plan
- Do NOT improve code style unless it's a documented issue
- Do NOT create helper scripts, utilities, or convenience functions unless they're part of the task
Your job is to complete the EXACT task assigned, nothing more.

ERROR HANDLING:
If you encounter errors you cannot resolve:
1. Log the error to DECISIONS_FILE_PATH with full details
2. Do NOT attempt to fix unrelated issues or work around the problem
3. Stop immediately - Ralph will handle recovery

Examples of errors to log and stop:
- Command fails with non-zero exit code
- File not found that should exist
- Git operation fails (conflicts, merge issues)
- Cannot parse or find required data

STATUS REPORTING (REQUIRED):
At the end of your response, you MUST include a status block for Ralph to parse:

---RALPH_STATUS---
STATUS: IN_PROGRESS | COMPLETE | BLOCKED
TASKS_COMPLETED_THIS_LOOP: <number>
FILES_MODIFIED: <number>
TESTS_STATUS: PASSING | FAILING | NOT_RUN
WORK_TYPE: IMPLEMENTATION | TESTING | DOCUMENTATION | REFACTORING
EXIT_SIGNAL: false | true
RECOMMENDATION: <one line summary of what to do next>
---END_RALPH_STATUS---

WHEN TO SET EXIT_SIGNAL:
Set EXIT_SIGNAL to true ONLY when ALL of these conditions are met:
1. All items in the plan are marked [x] or [~]
2. All tests are passing (or no tests exist for valid reasons)
3. No errors or warnings in the last execution
4. You have nothing meaningful left to implement for this task

CONCRETE EXAMPLES OF STATUS BLOCKS:

Example 1 - Making Progress (typical iteration):
---RALPH_STATUS---
STATUS: IN_PROGRESS
TASKS_COMPLETED_THIS_LOOP: 1
FILES_MODIFIED: 3
TESTS_STATUS: PASSING
WORK_TYPE: IMPLEMENTATION
EXIT_SIGNAL: false
RECOMMENDATION: Continue with next Phase 2 task from plan
---END_RALPH_STATUS---

Example 2 - Task Complete (all plan items done, tests passing):
---RALPH_STATUS---
STATUS: COMPLETE
TASKS_COMPLETED_THIS_LOOP: 1
FILES_MODIFIED: 1
TESTS_STATUS: PASSING
WORK_TYPE: DOCUMENTATION
EXIT_SIGNAL: true
RECOMMENDATION: All plan tasks complete, tests passing, ready for completion
---END_RALPH_STATUS---

Example 3 - Blocked/Stuck (same error repeatedly):
---RALPH_STATUS---
STATUS: BLOCKED
TASKS_COMPLETED_THIS_LOOP: 0
FILES_MODIFIED: 2
TESTS_STATUS: FAILING
WORK_TYPE: DEBUGGING
EXIT_SIGNAL: false
RECOMMENDATION: Stuck on import error - same failure 3 times, need investigation
---END_RALPH_STATUS---

Example 4 - Test-Only Loop (running tests without changes):
---RALPH_STATUS---
STATUS: IN_PROGRESS
TASKS_COMPLETED_THIS_LOOP: 0
FILES_MODIFIED: 0
TESTS_STATUS: PASSING
WORK_TYPE: TESTING
EXIT_SIGNAL: false
RECOMMENDATION: All tests passing, no implementation changes needed
---END_RALPH_STATUS---

CRITICAL ANTI-PATTERNS TO AVOID:
- Do NOT continue with busy work when EXIT_SIGNAL should be true
- Do NOT run tests repeatedly without implementing new features (test-only loops)
- Do NOT refactor code that is already working fine unless explicitly tasked
- Do NOT add features beyond what's in the plan (scope creep)
- Do NOT forget to include the status block (Ralph circuit breaker depends on it)
- Do NOT mark tasks complete that still have failing tests or errors

EXIT SCENARIOS (Specification by Example):

Scenario 1: Successful Phase Completion
GIVEN:
- All tasks in current phase are marked [x] in plan
- Tests are passing (or not yet run if before Phase 5)
- No errors in recent execution
- Files are properly staged/committed (if in Phase 9)

WHEN: You complete the last task in the phase

THEN: Output status with EXIT_SIGNAL: false (Ralph will detect phase completion and advance)
Example:
---RALPH_STATUS---
STATUS: IN_PROGRESS
TASKS_COMPLETED_THIS_LOOP: 1
FILES_MODIFIED: 2
TESTS_STATUS: PASSING
WORK_TYPE: IMPLEMENTATION
EXIT_SIGNAL: false
RECOMMENDATION: Phase 2 complete, all implementation tasks done
---END_RALPH_STATUS---

RALPH ACTION: Detects all Phase 2 tasks are [x], advances to Phase 3

---

Scenario 2: Complete Workflow (All Phases Done)
GIVEN:
- All Phase 9 (COMMIT) tasks are marked [x]
- Git commit was successfully created
- All tests passing from Phase 5
- All review tasks from Phase 3 and 7 are complete

WHEN: You complete the final commit task

THEN: Output status with EXIT_SIGNAL: true
Example:
---RALPH_STATUS---
STATUS: COMPLETE
TASKS_COMPLETED_THIS_LOOP: 1
FILES_MODIFIED: 0
TESTS_STATUS: PASSING
WORK_TYPE: DOCUMENTATION
EXIT_SIGNAL: true
RECOMMENDATION: All phases complete, commit created, workflow done
---END_RALPH_STATUS---

RALPH ACTION: Detects EXIT_SIGNAL: true, exits workflow successfully

---

Scenario 3: Test-Only Loop Detected (Stagnation)
GIVEN:
- Last 3 iterations only ran tests (npm test, pytest, etc.)
- No files were modified in those iterations
- No tasks were marked complete
- Tests are passing

WHEN: You run tests again without making changes

THEN: Output status indicating no progress
Example:
---RALPH_STATUS---
STATUS: IN_PROGRESS
TASKS_COMPLETED_THIS_LOOP: 0
FILES_MODIFIED: 0
TESTS_STATUS: PASSING
WORK_TYPE: TESTING
EXIT_SIGNAL: false
RECOMMENDATION: Tests passing, no changes needed, task may be complete
---END_RALPH_STATUS---

RALPH ACTION: Circuit breaker increments test-only counter, exits after 3 consecutive test-only loops

---

Scenario 4: Recurring Error (Stuck)
GIVEN:
- Same error appears in last 3 consecutive iterations
- Error message is identical or very similar
- Attempted fixes have not resolved the issue
- Making no forward progress

WHEN: You encounter the same error again

THEN: Output status indicating BLOCKED
Example:
---RALPH_STATUS---
STATUS: BLOCKED
TASKS_COMPLETED_THIS_LOOP: 0
FILES_MODIFIED: 3
TESTS_STATUS: FAILING
WORK_TYPE: DEBUGGING
EXIT_SIGNAL: false
RECOMMENDATION: Stuck on ModuleNotFoundError for 'foo.bar' - attempted 3 fixes
---END_RALPH_STATUS---

RALPH ACTION: Circuit breaker detects repeated errors, opens circuit and halts workflow

---

Scenario 5: No Progress Made (Multiple Iterations)
GIVEN:
- Last 3 iterations completed 0 tasks
- No files were modified
- Phase has unchecked tasks remaining
- No clear blocker identified

WHEN: Another iteration completes with no progress

THEN: Output status showing lack of progress
Example:
---RALPH_STATUS---
STATUS: IN_PROGRESS
TASKS_COMPLETED_THIS_LOOP: 0
FILES_MODIFIED: 0
TESTS_STATUS: NOT_RUN
WORK_TYPE: IMPLEMENTATION
EXIT_SIGNAL: false
RECOMMENDATION: Unable to make progress on current task, may need clarification
---END_RALPH_STATUS---

RALPH ACTION: Circuit breaker detects no-progress pattern, halts after 3 iterations

---

Scenario 6: Successfully Fixed Issue After Review
GIVEN:
- Phase 3 (REVIEW) identified issues and added tasks to Phase 4
- You completed Phase 4 fix tasks
- Ralph returned to Phase 3 for re-review
- Re-review found no new issues

WHEN: You complete re-review with no issues found

THEN: Mark review task [x], note clean review in decisions
Example:
---RALPH_STATUS---
STATUS: IN_PROGRESS
TASKS_COMPLETED_THIS_LOOP: 1
FILES_MODIFIED: 0
TESTS_STATUS: NOT_RUN
WORK_TYPE: REFACTORING
EXIT_SIGNAL: false
RECOMMENDATION: Re-review passed, no new issues found, ready for Phase 5
---END_RALPH_STATUS---

RALPH ACTION: Detects Phase 3 complete with no Phase 4 tasks, advances to Phase 5

---

Scenario 7: Phase 8 Fixes Trigger Full Re-Test Cycle
GIVEN:
- Phase 7 (FINAL-REVIEW) identified issues and added tasks to Phase 8
- You completed Phase 8 fix tasks
- Fixes could have introduced new bugs or broken tests

WHEN: You complete the last Phase 8 fix task

THEN: Mark task [x], note completion in decisions
Example:
---RALPH_STATUS---
STATUS: IN_PROGRESS
TASKS_COMPLETED_THIS_LOOP: 1
FILES_MODIFIED: 2
TESTS_STATUS: NOT_RUN
WORK_TYPE: REFACTORING
EXIT_SIGNAL: false
RECOMMENDATION: Phase 8 fixes complete, returning to Phase 5 for re-testing
---END_RALPH_STATUS---

RALPH ACTION: Detects Phase 8 complete, returns to Phase 5 (TEST) to ensure fixes didn't break anything, then proceeds through Phase 6 (FIX if needed), Phase 7 (FINAL-REVIEW), and Phase 9 (COMMIT if clean)

This ensures quality: any fix in Phase 8 triggers a full re-test and re-review cycle before commit.

LOGGING FORMAT for DECISIONS_FILE_PATH:

## [Iteration N] Phase X: Task Name

**Task:** (copy the exact task from plan)

**What I Did:**
- Concrete actions taken (commands run, files modified, etc.)

**Why:**
- Rationale for approach chosen

**Result:**
- Success or failure
- Key outputs, error messages, or findings
- Any follow-up work needed

Use this format for all decision logging to maintain consistency across iterations.

REMEMBER:
- Quality over speed - build it right the first time
- One task per iteration - resist the urge to batch work
- Know when you're done - don't invent work when the task is complete
- Execute and verify - don't just plan or document what should happen
- Your responses should be concise - complete the task, update the plan, log decisions, and STOP
EOF
}

# Get phase-specific instructions (sent as regular prompt, not system prompt)
get_phase_prompt() {
    local phase=$1

    case $phase in
        1)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH (if it exists) to understand previous iterations
2. Run 'git status' and 'git diff --stat' to see current state
3. Understand the requirements from the original task

TASK: Create an implementation plan in a markdown file at PLAN_FILE_PATH

The plan must be organized into these 9 phases:

## Phase 1: PLAN
List analysis tasks needed to understand the work (typically 2-4 tasks):
- Understand requirements and scope
- Review existing code and patterns
- Identify gaps and approach

After creating the plan, you must COMPLETE these Phase 1 tasks by marking them [x] before
Ralph will advance to Phase 2. Do thorough research for each task.

## Phase 2: IMPLEMENT
List ALL implementation tasks needed to complete the work. Break down into specific, actionable items:
- Each task should be concrete and specific
- Good: "- [ ] Create test_queue_models.py with tests for QueueModel.save() edge cases"
- Bad: "- [ ] Add tests" (too vague)
- Include code files, test files, and configuration changes
- Be thorough - list everything that needs to be created or modified

## Phase 3: REVIEW
List 1 review task:
- [ ] Review implementation for bugs, security issues, logic errors, and code quality

## Phase 4: FIX
(Leave this section EMPTY - just the header. Will be populated by Phase 3 review findings if issues found)

## Phase 5: TEST
List 1 test task:
- [ ] Run project tests, linter, and type checker

## Phase 6: FIX
(Leave this section EMPTY - just the header. Will be populated by Phase 5 if test failures occur)

## Phase 7: FINAL-REVIEW
List 1 final review task:
- [ ] Final review of all changes for quality, completeness, and correctness

## Phase 8: FIX
(Leave this section EMPTY - just the header. Will be populated by Phase 7 review findings if issues found)

## Phase 9: COMMIT
List 1 task:
- [ ] Create git commit with descriptive message following project conventions

IMPORTANT:
- Each task is a single line starting with '- [ ]' (markdown checkbox)
- Phases 4, 6, 8 should have ONLY the header line, no tasks (they're populated dynamically during review/test phases)
- Phase 1 tasks will be completed before advancing to Phase 2

Write the complete plan to PLAN_FILE_PATH (use Write tool). DO NOT implement anything yet.

After writing the plan, STOP. Ralph will call you again to complete Phase 1 tasks.
EOF
            ;;
        2)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand what happened in previous iterations
2. Run 'git status' and 'git diff --stat' to see current state
3. Read PLAN_FILE_PATH to see your specific task

TASK: Complete the next Phase 2 (IMPLEMENT) task from the plan.

CRITICAL - ONE TASK ONLY:
You MUST complete ONLY ONE task per iteration, even if you see multiple related tasks.
Ralph requires per-task granularity for progress tracking and phase management.
Do NOT batch multiple tasks together "for efficiency" - this breaks the autonomous workflow.

TESTING GUIDELINES (20% RULE):
- LIMIT testing to ~20% of your total effort per loop
- PRIORITIZE: Implementation > Documentation > Tests
- Only write tests for NEW functionality you implement
- Do NOT refactor existing tests unless broken
- Do NOT add "additional test coverage" as busy work
- Focus on CORE functionality first, comprehensive testing comes in Phase 5

STEPS:
1) Read PLAN_FILE_PATH
2) Find the FIRST unchecked Phase 2 task (line starting with '- [ ]' under ## Phase 2)
3) If all Phase 2 tasks are [x]:
   - Log to DECISIONS_FILE_PATH: "Phase 2 complete - all implementation tasks checked"
   - STOP immediately (Ralph will advance to Phase 3)
4) If unchecked task found:
   - Complete ONLY that ONE task (write code, tests, configs ONLY)
   - Mark it as done by changing '- [ ]' to '- [x]'
   - Log what you did in DECISIONS_FILE_PATH using the standard format
   - STOP IMMEDIATELY - do not continue to the next task

CRITICAL - DO NOT CREATE:
- Documentation files (SUMMARY.md, GUIDE.md, HOWTO.md, README.md, etc.)
- Test running guides (RUNNING_TESTS.md, TEST_GUIDE.md, etc.)
- Coverage reports or summaries as files
- Any markdown files explaining what you did

ONLY create: source code, test files, and configuration files that are part of the task.

After completing ONE task and marking it [x], STOP. Ralph will call you again for the next task.
EOF
            ;;
        3)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand what happened in previous iterations
2. Run 'git status' and 'git diff --stat' to see current state
3. Read PLAN_FILE_PATH to see your specific task

TASK: Review the implementation (Phase 3).

STEPS:
1) Read PLAN_FILE_PATH
2) Find the FIRST unchecked Phase 3 task (line starting with '- [ ]' under ## Phase 3)
3) If all Phase 3 tasks are [x]:
   - Log to DECISIONS_FILE_PATH: "Phase 3 complete - all review tasks checked"
   - STOP immediately (Ralph will advance based on Phase 4 status)
4) Check what files were created/modified THIS RUN:
   - Run 'git diff --name-only' to see modified files
   - Run 'git status --porcelain' to see new untracked files created during implementation

5) Perform thorough code review:
   - Bugs, security issues, code quality, edge cases
   - Logic errors, null checks, error handling
   - CHECK: Did implementation create unwanted documentation files?
     * Look for SUMMARY.md, GUIDE.md, HOWTO.md, etc. in git status/diff
     * Test running guides (RUNNING_TESTS.md, TEST_COVERAGE.md)
     * Only flag files that were CREATED during this run, not pre-existing files
   - CHECK: Will any sensitive files be committed?
     * Look at what files are staged or modified
     * Files like .env, .envrc, credentials.json should NOT be staged
     * But DO NOT delete pre-existing sensitive files - just ensure they're not staged

6) Log findings in DECISIONS_FILE_PATH using standard format
7) IF issues found:
   - ADD fix tasks to Phase 4 using the template below
   - ADD re-review task to Phase 3 if needed
8) IF clean: note "Review passed - no issues found" in DECISIONS_FILE_PATH
9) Mark current task as '- [x]' and STOP

HOW TO ADD FIX TASKS TO PHASE 4:
Use the Edit tool to add tasks after "## Phase 4: FIX" header, before "## Phase 5:" header.

Format each task as:
- [ ] Fix: <specific description of what needs fixing>

IMPORTANT - Only delete files that were CREATED during this implementation run:
- Files YOU created (SUMMARY.md, GUIDE.md, etc.) → Delete them
- Pre-existing project files (.envrc, .env, *.bak, local config files) → Just ensure not staged, DO NOT delete

Example - if you find 3 issues:

## Phase 4: FIX
- [ ] Fix: Delete tests/SUMMARY.md (documentation file created during implementation)
- [ ] Fix: Add input validation to login() function in auth.py (security issue)
- [ ] Fix: Ensure .envrc is not staged (pre-existing file with secrets, just unstage it)

## Phase 5: TEST

After adding fix tasks to Phase 4, add a re-review task to Phase 3 if this was the initial review:
- [ ] Re-review implementation after Phase 4 fixes are complete

After updating the plan and marking your task [x], STOP. Ralph will route to Phase 4 for fixes.
EOF
            ;;
        4)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand what issues were found in Phase 3
2. Run 'git status' and 'git diff --stat' to see current state
3. Read PLAN_FILE_PATH to see your specific fix task

TASK: Fix issues identified in Phase 3 review.

STEPS:
1) Read PLAN_FILE_PATH
2) Find the FIRST unchecked Phase 4 task (line starting with '- [ ]' under ## Phase 4)
3) If all Phase 4 tasks are [x]:
   - Log to DECISIONS_FILE_PATH: "Phase 4 complete - all fixes applied"
   - STOP immediately (Ralph will return to Phase 3 for re-review)
4) If unchecked task found:
   - Read the task description carefully (it should specify what needs fixing)
   - Complete ONLY that ONE fix
   - Mark as '- [x]'
   - Log the fix in DECISIONS_FILE_PATH using standard format
   - STOP IMMEDIATELY

IMPORTANT:
- Do NOT re-run review yourself - Ralph will return to Phase 3 after fixes
- Do NOT attempt to verify your fix by running tests - that happens in Phase 5
- Focus on fixing the specific issue described in the task
- One fix per iteration

After completing ONE fix and marking it [x], STOP. Ralph will call you again for the next fix or return to Phase 3.
EOF
            ;;
        5)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand what happened in previous iterations
2. Run 'git status' and 'git diff --stat' to see current state
3. Read PLAN_FILE_PATH to see your specific task

TASK: Run tests, linter, and type checker (Phase 5).

CRITICAL - ACTUAL EXECUTION REQUIRED:
You must ACTUALLY EXECUTE these commands, not just document how to run them.
Test suites may take 5-10+ minutes. Wait for complete execution. Do not timeout or skip.

STEPS:
1) Read PLAN_FILE_PATH and find FIRST unchecked Phase 5 task
2) If all Phase 5 tasks are [x]:
   - Log to DECISIONS_FILE_PATH: "Phase 5 complete - all tests checked"
   - STOP immediately (Ralph will advance based on Phase 6 status)
3) Discover project tools (check justfile, package.json, pyproject.toml, Makefile, .github/workflows)
4) EXECUTE all quality checks:
   - Tests (e.g., 'just test', 'uv run pytest', 'npm test')
   - Linter (e.g., 'just lint', 'uv run ruff check', 'npm run lint')
   - Type checker (e.g., 'uv run mypy', 'npm run typecheck')
   - Pre-commit hooks if configured

5) Wait for commands to complete, capture full output (this may take several minutes)
6) Log to DECISIONS_FILE_PATH: exact commands run, full output, pass/fail status
7) IF failures found:
   - ADD fix tasks to Phase 6 using template below
   - ADD re-test task to Phase 5
8) IF all pass: note "All tests passed" in DECISIONS_FILE_PATH
9) Mark current task as '- [x]' and STOP

HOW TO ADD FIX TASKS TO PHASE 6:
Use the Edit tool to add tasks after "## Phase 6: FIX" header, before "## Phase 7:" header.

Format each task as:
- [ ] Fix: <specific test/linter/type error with location>

Example - if you have test failures and linter errors:

## Phase 6: FIX
- [ ] Fix: test_login failing - TypeError at tests/test_auth.py:42
- [ ] Fix: test_user_create failing - AssertionError at tests/test_user.py:108
- [ ] Fix: Ruff error - unused import at src/utils.py:5
- [ ] Fix: Mypy error - incompatible type at src/models.py:67

## Phase 7: FINAL-REVIEW

After adding fix tasks to Phase 6, add a re-test task to Phase 5:
- [ ] Re-run tests after Phase 6 fixes are complete

After updating the plan and marking your task [x], STOP. Ralph will route to Phase 6 for fixes.
EOF
            ;;
        6)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand what test/linter failures occurred in Phase 5
2. Run 'git status' and 'git diff --stat' to see current state
3. Read PLAN_FILE_PATH to see your specific fix task

TASK: Fix test failures or linter issues identified in Phase 5.

STEPS:
1) Read PLAN_FILE_PATH
2) Find the FIRST unchecked Phase 6 task (line starting with '- [ ]' under ## Phase 6)
3) If all Phase 6 tasks are [x]:
   - Log to DECISIONS_FILE_PATH: "Phase 6 complete - all test/linter fixes applied"
   - STOP immediately (Ralph will return to Phase 5 for re-testing)
4) If unchecked task found:
   - Read the task description carefully (it should specify the test/linter error)
   - Complete ONLY that ONE fix
   - Mark as '- [x]'
   - Log the fix in DECISIONS_FILE_PATH using standard format
   - STOP IMMEDIATELY

IMPORTANT:
- Do NOT re-run tests yourself - Ralph will return to Phase 5 for re-testing
- Focus on fixing the specific test/linter/type error described in the task
- One fix per iteration

After completing ONE fix and marking it [x], STOP. Ralph will call you again for the next fix or return to Phase 5.
EOF
            ;;
        7)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand entire workflow and verify Phase 5 actually executed tests
2. Run 'git status' and 'git diff --stat' to see current state
3. Read PLAN_FILE_PATH to see your specific task

TASK: Final comprehensive review (Phase 7).

This is VERIFICATION - ensure everything was actually done correctly, not just documented.

STEPS:
1) Read PLAN_FILE_PATH and find FIRST unchecked Phase 7 task
2) If all Phase 7 tasks are [x]:
   - Log to DECISIONS_FILE_PATH: "Phase 7 complete - final review passed"
   - STOP immediately (Ralph will advance based on Phase 8 status)
3) Read DECISIONS_FILE_PATH thoroughly:
   - VERIFY Phase 5 actually executed tests/linter (look for command output, not just "I will run tests")
   - Verify commands were run and results logged
4) Run 'git status' and 'git diff --cached --name-only' to check staged files
5) Identify what files were CREATED during this run vs pre-existing:
   - Compare git status output against DECISIONS_FILE_PATH to see what was implemented
   - Files mentioned in Phase 2 implementation tasks = created during this run
   - Other files in git status = likely pre-existing

6) Perform final review:
   - VERIFY tests/linter/type-checker actually ran with real output
   - Verify all changes complete and correct
   - Check code quality, error handling, edge cases
   - CHECK git status for files that should NOT be committed:
     * Documentation files CREATED during implementation (SUMMARY.md, GUIDE.md, etc.)
     * Test running guides created during implementation
     * Markdown files in tests/ directory created during implementation
     * Pre-existing sensitive files (.envrc, .env, credentials.json) - should not be staged
   - Check NO .claude/ or .ralph/ files staged

7) Log findings in DECISIONS_FILE_PATH using standard format
8) IF issues found (unwanted files staged, tests not actually run, etc.):
   - ADD fix tasks to Phase 8 using template below
   - ADD re-review task to Phase 7
9) IF clean AND tests verified with actual output: note "Final review passed" in DECISIONS_FILE_PATH
10) Mark current task as '- [x]' and STOP

HOW TO ADD FIX TASKS TO PHASE 8:
Use the Edit tool to add tasks after "## Phase 8: FIX" header, before "## Phase 9:" header.

Format each task as:
- [ ] Fix: <specific issue requiring correction>

IMPORTANT - Only delete files that were CREATED during this implementation run:
- Files created during implementation (SUMMARY.md, GUIDE.md, etc.) → Delete them
- Pre-existing project files (.envrc, backup files, etc.) → Just unstage, DO NOT delete

Example:

## Phase 8: FIX
- [ ] Fix: Delete tests/SUMMARY.md (documentation file created during implementation)
- [ ] Fix: Unstage .envrc (pre-existing file with secrets, just remove from staging)
- [ ] Fix: Tests were not actually executed in Phase 5 - decisions.md shows only intent, not output

## Phase 9: COMMIT

After adding fix tasks to Phase 8, add a re-review task to Phase 7:
- [ ] Re-review after Phase 8 fixes are complete

After updating the plan and marking your task [x], STOP. Ralph will route to Phase 8 for fixes.
EOF
            ;;
        8)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand what issues were found in Phase 7 final review
2. Run 'git status' and 'git diff --stat' to see current state
3. Read PLAN_FILE_PATH to see your specific fix task

TASK: Fix issues identified in Phase 7 final review.

STEPS:
1) Read PLAN_FILE_PATH
2) Find the FIRST unchecked Phase 8 task (line starting with '- [ ]' under ## Phase 8)
3) If all Phase 8 tasks are [x]:
   - Log to DECISIONS_FILE_PATH: "Phase 8 complete - all final fixes applied"
   - STOP immediately (Ralph will return to Phase 5 to re-test, then re-review)
4) If unchecked task found:
   - Read the task description carefully (it should specify what needs fixing)
   - Complete ONLY that ONE fix
   - Mark as '- [x]'
   - Log the fix in DECISIONS_FILE_PATH using standard format
   - STOP IMMEDIATELY

IMPORTANT:
- Do NOT re-run tests or review yourself - Ralph will handle the full cycle
- After Phase 8 fixes, Ralph returns to Phase 5 (TEST) to ensure fixes didn't break anything
- Then proceeds through Phase 6 (FIX if needed), Phase 7 (FINAL-REVIEW), and Phase 9 (COMMIT)
- Focus on fixing the specific issue described in the task
- One fix per iteration

After completing ONE fix and marking it [x], STOP. Ralph will call you again for the next fix or return to Phase 5.
EOF
            ;;
        9)
            cat <<'EOF'
CONTEXT GATHERING (do this first):
1. Read DECISIONS_FILE_PATH to understand the complete work done
2. Run 'git status' and 'git diff --stat' to see all changes
3. Run 'git log -10 --oneline' to understand project commit message style and conventions
4. Read PLAN_FILE_PATH to see your specific task

TASK: Create git commit (Phase 9).

STEPS:
1) Read PLAN_FILE_PATH
2) Find the FIRST unchecked Phase 9 task
3) If all Phase 9 tasks are [x]:
   - STOP immediately (workflow complete)
4) Review recent commits to learn message format:
   - Run 'git log -10 --oneline' for style
   - Run 'git log -3' for detailed format
   - Note patterns: conventional commits? Sentence case? Past/present tense?

5) Review all changes:
   - Run 'git diff' to see unstaged changes
   - Run 'git diff --cached' to see already staged changes
   - Run 'git status' to see all files

6) Identify files created during implementation by reviewing DECISIONS_FILE_PATH and Phase 2 tasks

7) Before staging, CHECK for problematic files that should NOT be committed:
   - Documentation files YOU created during implementation (SUMMARY.md, GUIDE.md, etc.) → DO NOT stage
   - Test running guides you created (RUNNING_TESTS.md, TEST_COVERAGE.md) → DO NOT stage
   - Markdown files in tests/ directory you created → DO NOT stage
   - .claude/ or .ralph/ files → DO NOT stage
   - Pre-existing sensitive files (.envrc, .env, credentials.json) → DO NOT stage
   - Temporary backup files (*.bak) → DO NOT stage

8) Stage ONLY implementation files:
   - Source code (*.py, *.js, *.go, etc.)
   - Test files (test_*.py, *.test.js, etc.)
   - Configuration files (*.yaml, *.json, *.toml, etc.)
   - Use 'git add' for specific files, or 'git add -p' for interactive staging
   - Stage ONLY files that are part of the implementation

9) Check staged files:
   - Run 'git diff --cached --name-only' to verify only correct files staged
   - If any problematic files staged, unstage them with 'git reset HEAD <file>'

10) If nothing to commit (all files were filtered out):
    - Log to DECISIONS_FILE_PATH: "No files to commit - only documentation was created"
    - Mark Phase 9 task as '- [x]'
    - STOP

11) Create commit following project conventions you discovered:
    - Write a descriptive commit message explaining the what and why
    - Follow the format/style from 'git log' output
    - Use 'git commit' with appropriate message

12) Mark Phase 9 task as '- [x]'
13) Log commit details to DECISIONS_FILE_PATH
14) STOP

IMPORTANT:
- Do NOT push unless explicitly requested in the original task
- If unsure about commit message format, favor clear descriptive messages over clever ones
- The commit message should explain WHAT changed and WHY, not HOW (code shows that)

After creating commit and marking task [x], STOP. Workflow complete.
EOF
            ;;
    esac
}

# Run Claude with a message and iteration number
run_claude() {
    local message="$1"
    local iteration="$2"

    # Conditional logging and checks based on command
    if [ "$RALPH_CLAUDE_COMMAND" = "claude-jail" ]; then
        log_info "Running Claude in Docker sandbox..."

        # Check if Docker Desktop is running
        if ! docker info >/dev/null 2>&1; then
            log_error "Docker Desktop is not running"
            exit 1
        fi

        # Check if claude-jail is available
        if [ ! -x "$CLAUDE_CMD" ]; then
            log_error "claude-jail not found at: $CLAUDE_CMD"
            exit 1
        fi
    else
        log_info "Running Claude..."

        # Check if claude command is available
        if ! command -v "$CLAUDE_CMD" >/dev/null 2>&1; then
            log_error "Claude command not found: $CLAUDE_CMD"
            exit 1
        fi
    fi

    # Get current phase from state
    local state=$(load_state)
    local current_phase=$(echo "$state" | jq -r '.current_phase // 1')
    local phase_iterations=$(echo "$state" | jq -r '.phase_iterations // 0')
    local original_prompt="$message"

    # Get generic system prompt (same for all phases)
    local SYSTEM_PROMPT=$(get_system_prompt)

    # Get phase-specific instructions with actual file paths injected
    local PHASE_INSTRUCTIONS=$(get_phase_prompt "$current_phase" | sed "s|PLAN_FILE_PATH|$PLAN_FILE|g; s|DECISIONS_FILE_PATH|$DECISIONS_FILE|g")

    # Phase name for logging and context
    local phase_name
    case $current_phase in
        1) phase_name="PLAN" ;;
        2) phase_name="IMPLEMENT" ;;
        3) phase_name="REVIEW" ;;
        4) phase_name="FIX (post-review)" ;;
        5) phase_name="TEST" ;;
        6) phase_name="FIX (post-test)" ;;
        7) phase_name="FINAL-REVIEW" ;;
        8) phase_name="FIX (post-final-review)" ;;
        9) phase_name="COMMIT" ;;
        *) phase_name="UNKNOWN" ;;
    esac

    # Build loop context for iteration awareness
    local LOOP_CONTEXT=""
    if [ "$iteration" -gt 1 ]; then
        # Count tasks completed so far
        local completed_tasks=0
        if [ -f "$PLAN_FILE" ]; then
            completed_tasks=$(grep -c '^- \[x\]' "$PLAN_FILE" 2>/dev/null || echo "0")
        fi

        # Get recent activity from decisions file (last 3 entries)
        local recent_activity=""
        if [ -f "$DECISIONS_FILE" ]; then
            recent_activity=$(tail -50 "$DECISIONS_FILE" | grep -A 3 "^## \[Iteration" | tail -20)
        fi

        LOOP_CONTEXT="
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
LOOP CONTEXT (Iteration $iteration):
- Total iterations so far: $iteration
- Phase iterations: $phase_iterations
- Tasks completed: $completed_tasks
- Current phase: $current_phase ($phase_name)

Recent activity (last few decisions):
$recent_activity
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"
    fi

    # Build dynamic regular prompt
    local FULL_PROMPT
    if [ "$current_phase" = "1" ]; then
        # Phase 1: Just the original task + phase instructions
        FULL_PROMPT="Original task: $original_prompt
$LOOP_CONTEXT
Phase 1 (PLAN) instructions:
$PHASE_INSTRUCTIONS"
    else
        # Phases 2-9: Reference the plan document
        FULL_PROMPT="Original task: $original_prompt
Plan document: $PLAN_FILE
$LOOP_CONTEXT
Current phase: Phase $current_phase
Phase instructions:
$PHASE_INSTRUCTIONS"
    fi

    log_info "Phase $current_phase: $phase_name (iteration $phase_iterations in this phase)"

    # Show environment info for claude-jail
    if [ "$RALPH_CLAUDE_COMMAND" = "claude-jail" ]; then
        if [ -f ".claude/Dockerfile" ]; then
            log_info "Docker: Using custom .claude/Dockerfile"
        else
            log_info "Docker: Using base template (docker/sandbox-templates:claude-code)"
        fi
    fi

    log_info "Executing: $CLAUDE_CMD -p --system-prompt \"<generic>\" --permission-mode acceptEdits"

    # Log the phase-specific prompt being sent
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "PROMPT (Phase $current_phase - $phase_name):"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "$FULL_PROMPT"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    # Run Claude and capture output and exit code
    local output_file=$(mktemp)

    # Also save to a persistent location for circuit breaker analysis
    local persistent_output="$RUN_DIR/last_output.txt"

    if [ "$RALPH_CLAUDE_COMMAND" = "claude-jail" ]; then
        # claude-jail needs script wrapper for pseudo-TTY (docker sandbox requirement)
        script -q "$output_file" "$CLAUDE_CMD" -p --system-prompt "$SYSTEM_PROMPT" --permission-mode acceptEdits "$FULL_PROMPT" > /dev/null 2>&1
        local exit_code=$?
    else
        # Native claude handles TTY properly
        "$CLAUDE_CMD" -p --system-prompt "$SYSTEM_PROMPT" --permission-mode acceptEdits "$FULL_PROMPT" > "$output_file" 2>&1
        local exit_code=$?
    fi

    # Strip ANSI escape codes and save to persistent location for circuit breaker
    # The script command adds TTY control codes that break status block parsing
    # Use sed to remove ANSI escape sequences: ESC [ ... m
    sed 's/\x1b\[[0-9;]*m//g' "$output_file" > "$persistent_output"

    # Display the output
    cat "$output_file"

    if [ $exit_code -ne 0 ]; then
        log_error "$CLAUDE_CMD exited with code $exit_code"
        log_error "Last 20 lines of output:"
        tail -20 "$output_file" | while IFS= read -r line; do
            echo "  $line" >&2
        done
        rm -f "$output_file"
        return 1
    fi

    rm -f "$output_file"
    log_info "Claude finished successfully"
}

# Unstage any .claude/ or .ralph/ files that shouldn't be committed
unstage_ralph_files() {
    # Check if there are any staged files in .claude/ or .ralph/
    if git diff --cached --name-only | grep -qE '^\.claude/|^\.ralph/'; then
        log_warning "Unstaging .claude/ and .ralph/ files (should not be committed)"
        git reset HEAD .claude/ .ralph/ 2>/dev/null || true
    fi
}

# Parse status block from Claude's output
parse_status_block() {
    local output_file="$1"

    # Extract status block if it exists
    # More lenient pattern to handle potential whitespace or control chars
    # Use -F for fixed string matching and -- to prevent --- being interpreted as options
    if grep -qF -- "---RALPH_STATUS---" "$output_file"; then
        # Use awk to extract everything between the markers
        # Strip leading/trailing whitespace from each line
        # Use -- in grep to prevent pattern from being interpreted as option
        awk '/---RALPH_STATUS---/,/---END_RALPH_STATUS---/' "$output_file" | \
            grep -v -- "---.*RALPH_STATUS.*---" | \
            sed 's/^[[:space:]]*//; s/[[:space:]]*$//'
    fi
}

# Check if exit signal was set in status block
check_exit_signal() {
    local status_block="$1"

    # More lenient pattern - match EXIT_SIGNAL: true anywhere in line
    if echo "$status_block" | grep -qi "EXIT_SIGNAL:[[:space:]]*true"; then
        return 0  # Exit signal detected
    else
        return 1  # No exit signal
    fi
}

# Detect and handle circuit breaker conditions
check_circuit_breaker() {
    local output_file="$1"
    local iteration="$2"

    # Parse status block from output
    local status_block=$(parse_status_block "$output_file")

    # Debug: log if status block was found
    if [ -z "$status_block" ]; then
        log_warning "Circuit breaker: No status block found in output"
        return 0  # Don't trigger circuit breaker if we can't parse status
    fi

    # Check for EXIT_SIGNAL
    if check_exit_signal "$status_block"; then
        log_success "EXIT_SIGNAL detected in status block - workflow complete!"
        echo ""
        echo "Status Block:"
        echo "$status_block"
        echo ""
        return 2  # Special code for clean exit
    fi

    # Extract metrics from status block with more robust parsing
    # Use grep with lenient whitespace matching and awk to extract value
    local tasks_completed=$(echo "$status_block" | grep -i "TASKS_COMPLETED_THIS_LOOP:" | sed 's/.*:[[:space:]]*//' || echo "0")
    local files_modified=$(echo "$status_block" | grep -i "FILES_MODIFIED:" | sed 's/.*:[[:space:]]*//' || echo "0")
    local work_type=$(echo "$status_block" | grep -i "WORK_TYPE:" | sed 's/.*:[[:space:]]*//' || echo "")

    # Default to 0 if empty
    [ -z "$tasks_completed" ] && tasks_completed=0
    [ -z "$files_modified" ] && files_modified=0

    # Detect test-only loops (3+ consecutive loops with TESTING work type and no file modifications)
    if [ "$work_type" = "TESTING" ] && [ "$files_modified" = "0" ]; then
        TEST_ONLY_LOOP_COUNT=$((TEST_ONLY_LOOP_COUNT + 1))

        if [ $TEST_ONLY_LOOP_COUNT -ge 3 ]; then
            log_warning "Circuit breaker: Detected $TEST_ONLY_LOOP_COUNT consecutive test-only loops"
            log_warning "No files being modified, only running tests - likely stagnating"
            return 1
        fi
    else
        TEST_ONLY_LOOP_COUNT=0  # Reset counter
    fi

    # Detect no-progress loops (3+ loops with no tasks completed and no files modified)
    if [ "$tasks_completed" = "0" ] && [ "$files_modified" = "0" ]; then
        NO_PROGRESS_COUNT=$((NO_PROGRESS_COUNT + 1))

        if [ $NO_PROGRESS_COUNT -ge 3 ]; then
            log_warning "Circuit breaker: Detected $NO_PROGRESS_COUNT consecutive loops with no progress"
            log_warning "No tasks completed and no files modified - likely stuck"
            return 1
        fi
    else
        NO_PROGRESS_COUNT=0  # Reset counter
    fi

    # Detect repeated errors (check last 50 lines of output for error patterns)
    local current_errors=$(tail -50 "$output_file" | grep -i "error\|failed\|exception" | head -5 | sort -u)

    if [ -n "$current_errors" ] && [ "$current_errors" = "$LAST_ERROR_MSG" ]; then
        ERROR_REPEAT_COUNT=$((ERROR_REPEAT_COUNT + 1))

        if [ $ERROR_REPEAT_COUNT -ge 3 ]; then
            log_warning "Circuit breaker: Same error repeated $ERROR_REPEAT_COUNT times"
            log_warning "Error pattern:"
            echo "$current_errors" | head -3
            return 1
        fi
    else
        LAST_ERROR_MSG="$current_errors"
        ERROR_REPEAT_COUNT=0  # Reset if errors changed
    fi

    return 0  # No circuit breaker conditions met
}

# Main workflow - Simple loop like the original Ralph
# Based on: https://ghuntley.com/ralph/
# Original: while :; do cat PROMPT.md | claude-code ; done
run_workflow() {
    local prompt=$(load_state | jq -r '.prompt')

    log_info "Starting Ralph autonomous workflow..."
    log_info "Prompt: $prompt"
    echo ""

    # Show system prompt once at the beginning
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "SYSTEM PROMPT (used for all phases):"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    get_system_prompt
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    # Infinite loop - Claude will work until the task is complete
    while true; do
        if ! check_limits; then
            log_error "Stopping due to limits"
            exit 1
        fi

        # Update iteration count
        local state=$(load_state)
        local total=$(($(echo "$state" | jq -r '.total_iterations // 0') + 1))
        local current_phase=$(echo "$state" | jq -r '.current_phase // 1')
        local phase_iterations=$(echo "$state" | jq -r '.phase_iterations // 0')

        phase_iterations=$((phase_iterations + 1))
        update_state "{\"total_iterations\": $total, \"phase_iterations\": $phase_iterations}"

        # Phase name for logging
        local phase_name
        case $current_phase in
            1) phase_name="PLAN" ;;
            2) phase_name="IMPLEMENT" ;;
            3) phase_name="REVIEW" ;;
            4) phase_name="FIX (post-review)" ;;
            5) phase_name="TEST" ;;
            6) phase_name="FIX (post-test)" ;;
            7) phase_name="FINAL-REVIEW" ;;
            8) phase_name="FIX (post-final-review)" ;;
            9) phase_name="COMMIT" ;;
            *) phase_name="UNKNOWN" ;;
        esac

        log_info "Iteration $total - Phase $current_phase: $phase_name"
        echo ""

        # Run Claude with the prompt and iteration number
        # Iteration 1 forces planning, subsequent iterations execute one todo at a time
        if ! run_claude "$prompt" "$total"; then
            log_error "Claude execution failed, stopping workflow"
            exit 1
        fi

        # Check circuit breaker conditions (stagnation, repeated errors, exit signal)
        local circuit_breaker_output="$RUN_DIR/last_output.txt"
        if [ -f "$circuit_breaker_output" ]; then
            check_circuit_breaker "$circuit_breaker_output" "$total"
            local breaker_result=$?

            if [ $breaker_result -eq 2 ]; then
                # EXIT_SIGNAL detected - clean exit
                log_success "Workflow completed via EXIT_SIGNAL"
                break
            elif [ $breaker_result -eq 1 ]; then
                # Circuit breaker tripped - stagnation detected
                log_error "Circuit breaker triggered - halting workflow to prevent runaway loop"
                log_error "Review $RUN_DIR/last_output.txt and $DECISIONS_FILE for details"
                exit 1
            fi
        fi

        # Unstage any .claude/ or .ralph/ files (should never be committed)
        unstage_ralph_files

        # Check for phase dependencies - route to fix phases if they have work
        # This prevents getting stuck when review phases have tasks that depend on fix phases
        case $current_phase in
            3)
                # Phase 3 (REVIEW) - check if Phase 4 (FIX) has unchecked tasks
                if phase_has_unchecked 4; then
                    log_info "Phase 3 has dependency on Phase 4 - routing to Phase 4 first"
                    echo "" >> "$DECISIONS_FILE"
                    echo "## Phase Dependency Routing (Iteration $total)" >> "$DECISIONS_FILE"
                    echo "" >> "$DECISIONS_FILE"
                    echo "**From**: Phase 3 (REVIEW)" >> "$DECISIONS_FILE"
                    echo "**To**: Phase 4 (FIX)" >> "$DECISIONS_FILE"
                    echo "**Reason**: Phase 4 has unchecked fix tasks that must be completed before Phase 3 review can finish" >> "$DECISIONS_FILE"
                    echo "" >> "$DECISIONS_FILE"
                    update_state "{\"current_phase\": 4, \"phase_iterations\": 0}"
                    continue
                fi
                ;;
            5)
                # Phase 5 (TEST) - check if Phase 6 (FIX) has unchecked tasks
                if phase_has_unchecked 6; then
                    log_info "Phase 5 has dependency on Phase 6 - routing to Phase 6 first"
                    echo "" >> "$DECISIONS_FILE"
                    echo "## Phase Dependency Routing (Iteration $total)" >> "$DECISIONS_FILE"
                    echo "" >> "$DECISIONS_FILE"
                    echo "**From**: Phase 5 (TEST)" >> "$DECISIONS_FILE"
                    echo "**To**: Phase 6 (FIX)" >> "$DECISIONS_FILE"
                    echo "**Reason**: Phase 6 has unchecked fix tasks that must be completed before Phase 5 testing can finish" >> "$DECISIONS_FILE"
                    echo "" >> "$DECISIONS_FILE"
                    update_state "{\"current_phase\": 6, \"phase_iterations\": 0}"
                    continue
                fi
                ;;
            7)
                # Phase 7 (FINAL-REVIEW) - check if Phase 8 (FIX) has unchecked tasks
                if phase_has_unchecked 8; then
                    log_info "Phase 7 has dependency on Phase 8 - routing to Phase 8 first"
                    echo "" >> "$DECISIONS_FILE"
                    echo "## Phase Dependency Routing (Iteration $total)" >> "$DECISIONS_FILE"
                    echo "" >> "$DECISIONS_FILE"
                    echo "**From**: Phase 7 (FINAL-REVIEW)" >> "$DECISIONS_FILE"
                    echo "**To**: Phase 8 (FIX)" >> "$DECISIONS_FILE"
                    echo "**Reason**: Phase 8 has unchecked fix tasks that must be completed before Phase 7 final review can finish" >> "$DECISIONS_FILE"
                    echo "" >> "$DECISIONS_FILE"
                    update_state "{\"current_phase\": 8, \"phase_iterations\": 0}"
                    continue
                fi
                ;;
        esac

        # Check for phase completion and transition
        if detect_phase_completion "$current_phase"; then
            local next_phase=$(determine_next_phase "$current_phase")

            if [ "$next_phase" = "done" ]; then
                log_success "Ralph workflow complete - Phase 9 (COMMIT) finished"
                break
            elif [ "$next_phase" = "error" ]; then
                log_error "Invalid phase transition from phase $current_phase"
                exit 1
            elif [ "$next_phase" != "$current_phase" ]; then
                # Phase transition
                log_info "Phase $current_phase ($phase_name) complete → advancing to Phase $next_phase"

                # Log phase transition
                echo "" >> "$DECISIONS_FILE"
                echo "## Phase Transition (Iteration $total)" >> "$DECISIONS_FILE"
                echo "" >> "$DECISIONS_FILE"
                echo "**From**: Phase $current_phase ($phase_name)" >> "$DECISIONS_FILE"
                echo "**To**: Phase $next_phase" >> "$DECISIONS_FILE"
                echo "" >> "$DECISIONS_FILE"

                # Update state with new phase
                update_state "{\"current_phase\": $next_phase, \"phase_iterations\": 0}"
            fi
        fi

        # Check if Claude created plan (required in Phase 1)
        if [ "$current_phase" = "1" ] && [ ! -f "$PLAN_FILE" ]; then
            log_error "Phase 1 MUST create $PLAN_FILE but none was created!"
            log_warning "Will retry Phase 1..."

            # Reset phase iterations to retry
            update_state "{\"phase_iterations\": 0}"
            sleep 2
            continue
        fi

        # Show task status if plan exists
        if [ -f "$PLAN_FILE" ]; then
            local unchecked_count=$(grep -c '^- \[ \]' "$PLAN_FILE" 2>/dev/null || echo "0")
            local checked_count=$(grep -c '^- \[x\]' "$PLAN_FILE" 2>/dev/null || echo "0")
            local skipped_count=$(grep -c '^- \[~\]' "$PLAN_FILE" 2>/dev/null || echo "0")

            if [ "$skipped_count" != "0" ]; then
                log_info "Task status: $checked_count completed, $skipped_count skipped, $unchecked_count remaining"
            else
                log_info "Task status: $checked_count completed, $unchecked_count remaining"
            fi
        fi

        # Small delay between iterations to avoid tight loops
        sleep 2
    done

    # Copy state files to run directory (plan.md and decisions.md already there)
    log_info "Archiving run artifacts to: $RUN_DIR"

    [ -f "$STATE_FILE" ] && cp "$STATE_FILE" "$RUN_DIR/" || true
    [ -f "$CLAUDE_DIR/todos.json" ] && cp "$CLAUDE_DIR/todos.json" "$RUN_DIR/" || true

    echo ""
    local state=$(load_state)
    local iterations=$(echo "$state" | jq -r '.total_iterations')
    echo "Summary:"
    echo "  Run ID: $RALPH_RUN_ID"
    echo "  Run directory: $RUN_DIR"
    echo "  Total iterations: $iterations"

    # Show task completion status from plan file
    if [ -f "$PLAN_FILE" ]; then
        local completed_tasks=$(grep -c '^- \[x\]' "$PLAN_FILE" 2>/dev/null || echo "0")
        local skipped_tasks=$(grep -c '^- \[~\]' "$PLAN_FILE" 2>/dev/null || echo "0")
        local unchecked_tasks=$(grep -c '^- \[ \]' "$PLAN_FILE" 2>/dev/null || echo "0")
        local total_tasks=$((completed_tasks + skipped_tasks + unchecked_tasks))

        if [ "$skipped_tasks" != "0" ]; then
            echo "  Tasks: $completed_tasks completed, $skipped_tasks skipped, $unchecked_tasks remaining (total: $total_tasks)"
        else
            echo "  Tasks: $completed_tasks/$total_tasks completed"
        fi
    fi
    echo ""

    # Check if decisions were logged
    if [ -f "$DECISIONS_FILE" ]; then
        log_warning "Ralph made decisions during autonomous operation"
        echo ""
        echo "Review decisions made: $DECISIONS_FILE"
        echo ""
        cat "$DECISIONS_FILE"
        echo ""
    fi
}

# Main
main() {
    # Parse arguments
    local resume=false
    local prompt_arg=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --resume)
                resume=true
                shift
                ;;
            --help|-h)
                usage
                ;;
            *)
                prompt_arg="$1"
                shift
                ;;
        esac
    done

    # Initialize directories
    init_dirs

    # Archive old state files before starting new run
    archive_old_state

    # Get prompt
    if [ "$resume" = true ]; then
        log_info "Resuming from checkpoint..."
        if [ ! -f "$STATE_FILE" ]; then
            log_error "No state file found to resume from"
            exit 1
        fi
    else
        if [ -z "$prompt_arg" ] && [ -t 0 ]; then
            log_error "No prompt provided"
            usage
        fi

        local prompt=$(get_prompt "$prompt_arg")

        if [ -z "$prompt" ]; then
            log_error "Empty prompt"
            exit 1
        fi

        log_info "Initializing Ralph workflow..."
        init_state "$prompt"
    fi

    # Start audit log with unbuffered output
    local audit_log="$RALPH_AUDIT_DIR/ralph-$(date +%Y%m%d-%H%M%S).log"
    exec > >(stdbuf -oL -eL tee -a "$audit_log") 2>&1

    log_info "Run ID: $RALPH_RUN_ID"
    log_info "Run directory: $RUN_DIR"
    log_info "Audit log: $audit_log"
    log_info "Max iterations: $RALPH_MAX_ITERATIONS"
    log_info "Cost limit: $RALPH_COST_LIMIT USD"

    # Run workflow
    run_workflow

    log_success "All done!"
}

# Run
main "$@"
